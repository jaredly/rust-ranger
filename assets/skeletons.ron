Skeletons(
    fns: {
    // "leg_off_x": Fn(args: ["inv"], body: )
},
shared: {
    "run_freq": Plain(1000.0),
    "vx_sin": Mul(Sin(Mul(TAU, Div(Time, Shared("run_freq")))), Abs(Vx)),
    "vx_sin_half": Mul(Sin(Mul(TAU, Div(Time, Div(Shared("run_freq"), Plain(2.0))))), Abs(Vx)),
    "vx_cos_half": Mul(
        Mul(Add(
            Sin(Mul(TAU, Div(Time, Div(Shared("run_freq"), Plain(2.0))))),
            Plain(1.0),
        ), Plain(0.5)),
        Abs(Vx)
    ),
    "leg_pos": Plain(60),
    "body_offset": Mul(Abs(Shared("vx_sin")), Plain(4.0)),
},
shared_bones: {},
skeletons: {
    "female": Skeleton(
        shape: Capsule(width: 0.1, height: 0.1),
        scale: Plain(0.3),
                // offset: (Plain(0.0), Plain(0.0)),
        // offset: Plain((0.0, 0.0)),
        offset: (Plain(0.0), Shared("body_offset")),
        // flip_left_right: true,
        bones: [
            Plain(Bone(
                sprite: "female_arm.png",
                pivot_offset: (Plain(0.0), Plain(-0.3)),
                offset: (
                    Mul(Shared("vx_sin"), Plain(1.0)),
                    Plain(-20)
                ),
                scale: Plain(1.0),
                rotation: Mul(Shared("vx_sin"), Plain(-10.0)),
            )),
            Plain(Bone(
                sprite: "female_leg.png",
                offset: (Mul(Shared("vx_sin"), Plain(-5.0)), Add(Shared("leg_pos"), Mul(Plain(-1), Shared("body_offset")))),
                pivot_offset: (Plain(0.0), Plain(-0.3)),
                scale: Plain(1.0),
                rotation: Mul(Shared("vx_sin"), Plain(5.0)),
            )),
            Plain(Bone(
                sprite: "female_leg.png",
                offset: (Mul(Shared("vx_sin"), Plain(5.0)), Add(Shared("leg_pos"), Mul(Plain(-1), Shared("body_offset")))),
                pivot_offset: (Plain(0.0), Plain(-0.3)),
                scale: Plain(1.0),
                rotation: Mul(Shared("vx_sin"), Plain(-5.0)),
            )),
            Plain(Bone(
                sprite: "female_body.png",
                offset: (Plain(0.0), Plain(0.0)),
                scale: Plain(1.0),
                rotation: Plain(0.0),
                pivot_offset: (Plain(0.0), Plain(0.0)),
            )),
            Plain(Bone(
                sprite: "female_head.png",
                offset: (Plain(0.0), Plain(-80.0)),
                pivot_offset: (Plain(-0.1), Plain(0.0)),
                scale: Plain(1.0),
                rotation: Plain(0.0),
            )),
            StrMatch("arm_action", {
                "none": Plain(Bone(
                    sprite: "female_arm.png",
                    offset: (Mul(Shared("vx_sin"), Plain(-0.1)), Plain(-20)),
                    pivot_offset: (Plain(0.0), Plain(-0.3)),
                    scale: Plain(1.0),
                    rotation: Mul(Shared("vx_sin"), Plain(10.0)),
                )),
                "throw": Plain(Bone(
                    sprite: "female_arm.png",
                    offset: (Plain(0.0), Plain(-20)),
                    pivot_offset: (Plain(0.0), Plain(-0.3)),
                    scale: Plain(1.0),
                    rotation: Mul(Div(Var("throw_theta"), PI), Plain(180)),
                ))
            }),
            // IfStrEq(key: "action", value: "walk", yes: , no: None),
        ]
    )
})
/**
Ok what would a good system look like here?

// (define female_skeleton [])
it would be great to have a language that looks & feels like rust as much as possible.

rhai looks decent
but maybe doesn't separate parsing from evaluating
but I can do that. dunno how long that takes



*/